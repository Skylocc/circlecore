

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>circleguard.loadables &mdash; Circleguard v4.5.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Circleguard
          

          
          </a>

          
            
            
              <div class="version">
                v4.5.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Circlecore</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../foreword.html">Foreword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../representing-replays.html">Representing Replays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using-circleguard.html">Using Circleguard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../replay-containers.html">|ReplayContainer|s</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loading.html">Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../caching.html">Caching</a></li>
</ul>
<p class="caption"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../appendix.html">Appendix</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Circleguard</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>circleguard.loadables</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for circleguard.loadables</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">circleparse</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">wtc</span>

<span class="kn">from</span> <span class="nn">circleguard.mod</span> <span class="k">import</span> <span class="n">Mod</span>
<span class="kn">from</span> <span class="nn">circleguard.utils</span> <span class="k">import</span> <span class="n">TRACE</span><span class="p">,</span> <span class="n">KEY_MASK</span><span class="p">,</span> <span class="n">RatelimitWeight</span>
<span class="kn">from</span> <span class="nn">circleguard.loader</span> <span class="k">import</span> <span class="n">Loader</span>
<span class="kn">from</span> <span class="nn">circleguard.span</span> <span class="k">import</span> <span class="n">Span</span>
<span class="kn">from</span> <span class="nn">circleguard.game_version</span> <span class="k">import</span> <span class="n">GameVersion</span><span class="p">,</span> <span class="n">NoGameVersion</span>
<span class="kn">from</span> <span class="nn">circleguard.map_info</span> <span class="k">import</span> <span class="n">MapInfo</span>

<div class="viewcode-block" id="Loadable"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Loadable">[docs]</a><span class="k">class</span> <span class="nc">Loadable</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents one or multiple replays, which have replay data to be loaded</span>
<span class="sd">    from some additional source - the osu! api, local cache, or some other</span>
<span class="sd">    location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replay data once loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>

<div class="viewcode-block" id="Loadable.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Loadable.load">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the information this loadable needs to become fully loaded.</span>
<span class="sd">        Details left to the subclass implementation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~circleguard.loader.Loader`</span>
<span class="sd">            The loader to load this loadable with. Although subclasses may not</span>
<span class="sd">            end up using a :class:`~circleguard.loader.Loader` to load</span>
<span class="sd">            themselves (if they don&#39;t load anything from the osu api, for</span>
<span class="sd">            instance), a loader is still passed regardless.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache the replay data once loaded. This argument</span>
<span class="sd">            comes from a parentâ€”either a :class:`~.ReplayContainer` or</span>
<span class="sd">            :class:`~circleguard.circleguard.Circleguard` itself. Should the</span>
<span class="sd">            loadable already have a set ``cache`` value, that should take</span>
<span class="sd">            precedence over the option passed in this method, but if the</span>
<span class="sd">            loadable has no preference then it should respect the value passed</span>
<span class="sd">            here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="LoadableContainer"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer">[docs]</a><span class="k">class</span> <span class="nc">LoadableContainer</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Loadable that holds Loadables, which may be ``ReplayContainer``\s or</span>
<span class="sd">    ``Replay``\s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loadables: list[:class:`~.Loadable`]</span>
<span class="sd">        The loadables to hold.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the loadables once they are loaded. This will be</span>
<span class="sd">        overriden by a ``cache`` option set by a :class:`~Loadable` in</span>
<span class="sd">        ``loadables``. This only affects child loadables when they do not have</span>
<span class="sd">        a ``cache`` option set.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is intended for situations when you have a list of replays and</span>
<span class="sd">    replay containers, but no way to separate or distinguish them. If you want</span>
<span class="sd">    to get, say, all the replays out of that list (whether they come from</span>
<span class="sd">    replay subclasses already in the list, or the replays held by a replay</span>
<span class="sd">    container in the list), this loadable container class has the logic to do</span>
<span class="sd">    that for you:</span>

<span class="sd">    &gt;&gt;&gt; lc = LoadableContainer(mixed_loadable_list)</span>
<span class="sd">    &gt;&gt;&gt; replays = lc.all_replays()</span>

<span class="sd">    It can also be useful to info load the replay containers in the list,</span>
<span class="sd">    without first filtering the list to remove any replay subclasses:</span>

<span class="sd">    &gt;&gt;&gt; cg.load_info(lc)</span>
<span class="sd">    &gt;&gt;&gt; # all loadable containers in the list are now info loaded</span>
<span class="sd">    &gt;&gt;&gt; cg.load(lc)</span>
<span class="sd">    &gt;&gt;&gt; # all loadables in the list are now loaded</span>

<span class="sd">    You are very unlikely to want to subclass this class. If you want to add a</span>
<span class="sd">    new loadable that holds replays, subclass ``ReplayContainer``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadables</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span> <span class="o">=</span> <span class="n">loadables</span>

<div class="viewcode-block" id="LoadableContainer.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All the :class:`~.Replay`\s in this loadable container.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[:class:`~Replay`]</span>
<span class="sd">            All the replays in this loadable container.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This list will almost may be incomplete if you do not call</span>
<span class="sd">        :func:`~.load_info` on this loadable container first, as any replay</span>
<span class="sd">        containers held in this container will likely not have references to</span>
<span class="sd">        their replays yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayContainer</span><span class="p">):</span>
                <span class="n">replays</span> <span class="o">+=</span> <span class="n">loadable</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># loadable is a Replay if it&#39;s not a ReplayContainer</span>
                <span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadable</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">replays</span></div>

<div class="viewcode-block" id="LoadableContainer.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="n">cascade_cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="n">loadable</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">cascade_cache</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayContainer</span><span class="p">):</span>
                <span class="n">loadable</span><span class="o">.</span><span class="n">load_info</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">LoadableContainer</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReplayContainer"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer">[docs]</a><span class="k">class</span> <span class="nc">ReplayContainer</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Loadable that holds Replay subclasses, and which has an additional state</span>
<span class="sd">    between &quot;unloaded&quot; and &quot;loaded&quot; called &quot;info loaded&quot;.</span>

<span class="sd">    ReplayContainers start unloaded and become info loaded when</span>
<span class="sd">    :meth:`~.load_info` is called. They become fully loaded when</span>
<span class="sd">    :meth:`~.load` is called (and if this is called when the ReplayContainer is</span>
<span class="sd">    in the unloaded state, :meth:`~Loadable.load` will load info first, then</span>
<span class="sd">    load the replays, effectively skipping the info loaded state),</span>

<span class="sd">    In the unloaded state, the container has no actual Replay objects. It may</span>
<span class="sd">    have limited knowledge about their number or type.</span>

<span class="sd">    In the info loaded state, the container has references to Replay objects,</span>
<span class="sd">    but those Replay objects are unloaded.</span>

<span class="sd">    In the loaded state, the Replay objects in the container are loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="ReplayContainer.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads all :class:`~circleguard.loadables.Loadable`\s contained by this</span>
<span class="sd">        loadable container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~circleguard.loader.Loader`</span>
<span class="sd">            The loader to load the :class:`~circleguard.loadables.Loadable`\s</span>
<span class="sd">            with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">cascade_cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_info</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">replay</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">():</span>
            <span class="n">replay</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">cascade_cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="ReplayContainer.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer.all_replays">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all the :class:`~.Replay`\s in this loadable container.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        If you want an accurate list of :class:`~.Replay`\s in this instance,</span>
<span class="sd">        you must call :func:`~circleguard.circleguard.Circleguard.load` on this</span>
<span class="sd">        instance before :func:`~.all_replays`. Otherwise, this</span>
<span class="sd">        instance is not info loaded, and does not have a complete list of</span>
<span class="sd">        replays it represents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">replays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">replays</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">replays</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">())</span></div>



<div class="viewcode-block" id="Map"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Map">[docs]</a><span class="k">class</span> <span class="nc">Map</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A map&#39;s top plays (leaderboard), as seen on the website.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The map to represent the top plays for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of top plays to retrieve.</span>
<span class="sd">        ``span=&quot;1-3,6,2-4&quot;`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        If passed, only represent replays played with this exact mod</span>
<span class="sd">        combination. Due to limitations with the api, fuzzy matching is not</span>
<span class="sd">        implemented.</span>
<span class="sd">        &lt;br&gt;</span>
<span class="sd">        This is applied before span``. That is, if ``span=&quot;1-2&quot;``</span>
<span class="sd">        and ``mods=Mod.HD``, the top two ``HD`` plays on the map are</span>
<span class="sd">        represented.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span>
            <span class="n">mods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span>
                <span class="n">cache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Map.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Map.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">map_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;Map(map_id=</span><span class="si">{self.map_id}</span><span class="s2">,cache=</span><span class="si">{self.cache}</span><span class="s2">,mods=</span><span class="si">{self.mods}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;span=</span><span class="si">{self.span}</span><span class="s2">,replays=</span><span class="si">{self.replays}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;loaded=</span><span class="si">{self.loaded}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;Map </span><span class="si">{self.map_id}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="User"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.User">[docs]</a><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A user&#39;s top plays (pp-wise, as seen on the website).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The user to represent the top plays for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of top plays to retrieve.</span>
<span class="sd">        ``span=&quot;1-3,6,2-4&quot;`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        If passed, only represent replays played with this exact mod</span>
<span class="sd">        combination. Due to limitations with the api, fuzzy matching is not</span>
<span class="sd">        implemented.</span>
<span class="sd">        &lt;br&gt;</span>
<span class="sd">        This is applied before ``span``. That is, if ``span=&quot;1-2&quot;``</span>
<span class="sd">        and ``mods=Mod.HD``, the user&#39;s top two ``HD`` plays are represented.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    available_only: bool</span>
<span class="sd">        Whether to represent only replays that have replay data available.</span>
<span class="sd">        Replays are filtered on this basis after ``mods`` and ``span``</span>
<span class="sd">        are applied. True by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> \
        <span class="n">available_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="o">=</span> <span class="n">available_only</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_user_best</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_available</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="User.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.User.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">User</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapUser"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.MapUser">[docs]</a><span class="k">class</span> <span class="nc">MapUser</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    All replays on a map by a user, not just the top replay.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The map to represent scores by `user_id` on.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The user to represent scores on `map_id` for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of plays to retrieve.</span>
<span class="sd">        ``span=&quot;1-3,6,2-4&quot;`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    available_only: bool</span>
<span class="sd">        Whether to represent only replays that have replay data available.</span>
<span class="sd">        Replays are filtered on this basis after ``span`` is applied.</span>
<span class="sd">        True by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="n">Loader</span><span class="o">.</span><span class="n">MAX_MAP_SPAN</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> \
        <span class="n">available_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="o">=</span> <span class="n">available_only</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span>
            <span class="n">user_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_available</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="MapUser.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.MapUser.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">MapUser</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">map_id</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayCache"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayCache">[docs]</a><span class="k">class</span> <span class="nc">ReplayCache</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contains replays represented by a circlecore database. Primarily useful</span>
<span class="sd">    to randomly sample these replays, rather than directly access them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: string</span>
<span class="sd">        The path to the database to load replays from.</span>
<span class="sd">    num_maps: int</span>
<span class="sd">        How many (randomly chosen) maps to load replays from.</span>
<span class="sd">    limit: int</span>
<span class="sd">        How many replays to load for each map.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    :meth:`~.load_info` is an expensive operation for large databases created</span>
<span class="sd">    on circlecore version 4.3.5 or earlier, as they do not have the necessary</span>
<span class="sd">    indexes.</span>
<span class="sd">    For databases created in later versions, this is a nonissue and the lookup</span>
<span class="sd">    is fast.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">,</span> <span class="n">num_replays</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">=</span> <span class="n">num_maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">num_replays</span> <span class="o">*</span> <span class="n">num_maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">map_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SELECT DISTINCT map_id</span>
<span class="sd">            FROM replays</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>

        <span class="c1"># flatten map_ids, because it&#39;s actually a list of lists</span>
        <span class="n">map_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">map_ids</span><span class="p">]</span>
        <span class="n">chosen_maps</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">map_ids</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span><span class="p">)</span>

        <span class="n">subclauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;map_id = </span><span class="si">{chosen_map}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">chosen_map</span> <span class="ow">in</span> <span class="n">chosen_maps</span><span class="p">]</span>
        <span class="n">where_clause</span> <span class="o">=</span> <span class="s2">&quot; OR &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subclauses</span><span class="p">)</span>

        <span class="c1"># TODO LIMIT clause isn&#39;t quite right here, some maps will have less</span>
        <span class="c1"># than ``num_replays`` stored</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="n">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT user_id, map_id, replay_data, replay_id, mods</span>
<span class="s2">            FROM replays</span>
<span class="s2">            WHERE </span><span class="si">{where_clause}</span><span class="s2"></span>
<span class="s2">            LIMIT </span><span class="si">{self.limit}</span><span class="s2"></span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">infos</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">CachedReplay</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ReplayCache.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayCache.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">path</span></div>


<div class="viewcode-block" id="ReplayDir"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDir">[docs]</a><span class="k">class</span> <span class="nc">ReplayDir</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A folder with replay files inside it.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Any files not ending in ``.osr`` are ignored.</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    Nested directories are not support (yet). Any folders encountered will be</span>
<span class="sd">    ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dir_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Expected path pointing to </span><span class="si">{self.dir_path}</span><span class="s2"> to be&quot;</span>
                <span class="s2">&quot; a directory&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.osr&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">replay</span> <span class="o">=</span> <span class="n">ReplayPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">/</span> <span class="n">path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replay</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ReplayDir.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDir.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dir_path</span></div>


<div class="viewcode-block" id="Replay"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay">[docs]</a><span class="k">class</span> <span class="nc">Replay</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A replay played by a player.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight: :class:`~circleguard.utils.RatelimitWeight`</span>
<span class="sd">        How much it &#39;costs&#39; to load this replay from the api.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    game_version: :class:`~circleguard.game_version.GameVersion`</span>
<span class="sd">        Information about the version of osu! the replay was played on.</span>
<span class="sd">    timestamp: :class:`datetime.datetime`</span>
<span class="sd">        When the replay was played.</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The id of the map the replay was played on, or 0 if</span>
<span class="sd">        unknown or on an unsubmitted map.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The id of the player who played the replay, or 0 if unknown</span>
<span class="sd">        (if the player is restricted, for instance). Note that if the</span>
<span class="sd">        user id is known, even if the user is restricted, it should still be</span>
<span class="sd">        given instead of 0.</span>
<span class="sd">    username: str</span>
<span class="sd">        The username of the player who played the replay.</span>
<span class="sd">    mods: :class:`~circleguard.mods.ModCombination`</span>
<span class="sd">        The mods the replay was played with.</span>
<span class="sd">    replay_id: int</span>
<span class="sd">        The id of the replay, or 0 if the replay is unsubmitted.</span>
<span class="sd">    keydowns: ndarray[int]</span>
<span class="sd">        The keydowns for each frame of the replay. Keydowns are the keys pressed</span>
<span class="sd">        in that frame that were not pressed in the previous frame. See</span>
<span class="sd">        :meth:`~.keydowns` for more details.</span>
<span class="sd">    t: ndarray[int]</span>
<span class="sd">        A 1d array containing the timestamp for each frame.</span>
<span class="sd">        &lt;br&gt;</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    xy: ndarray[float]</span>
<span class="sd">        A 2d, two column array, containing the ``x`` and ``y`` coordinates of</span>
<span class="sd">        each frame in the first and second column respectively.</span>
<span class="sd">        &lt;br&gt;</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    k: ndarray[int]</span>
<span class="sd">        A 1d array containing the keys pressed for each frame.</span>
<span class="sd">        &lt;br&gt;</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>

        <span class="c1"># These attributes might or might not be set once the replay loads.</span>
        <span class="c1"># Ideally, a replay would provide all of these attributes, but there are</span>
        <span class="c1"># some cases when only a subset is available. &lt;br&gt;</span>
        <span class="c1"># If only some of these attributes are set after the replay is loaded,</span>
        <span class="c1"># some ``Circleguard`` methods may reject this replay, as it does not</span>
        <span class="c1"># contain the information necessary to do whatever the method needs to.</span>
        <span class="c1"># &lt;br&gt;</span>
        <span class="c1"># For instance, if the replay provides ``replay_data`` but not ``mods``,</span>
        <span class="c1"># ``Circleguard#similarity`` will reject it, as we will not know whether</span>
        <span class="c1"># whether ``Mod.HR`` was enabled on the replay, and thus whether to flip</span>
        <span class="c1"># the replay before comparing it to another one.</span>

        <span class="c1"># replays have no information about their game version by default.</span>
        <span class="c1"># Subclasses might set this if they have more information to provide</span>
        <span class="c1"># about their version, whether on instantiation or after being loaded.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">NoGameVersion</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span>    <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># declared as a property with a getter and setter so we can set</span>
        <span class="c1"># map_info&#39;s map_id attribute automatically</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_id</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># replays have no information about their map by default.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span>     <span class="o">=</span> <span class="n">MapInfo</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span>      <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span>         <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span>    <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span>  <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># These attributes remain ``None``` when replay is unloaded or loaded</span>
        <span class="c1"># but with no data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span>            <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>           <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span>            <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span>    <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Replay.has_data"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay.has_data">[docs]</a>    <span class="k">def</span> <span class="nf">has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether this replay has any replay data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether this replay has any replay data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If this replay is unloaded, it is guaranteed to not have any replay</span>
<span class="sd">        data. But if the replay is loaded, it is not guaranteed to have any</span>
<span class="sd">        replay data. Some replays do not have any replay data available from</span>
<span class="sd">        the api, even after being loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Replay.beatmap"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay.beatmap">[docs]</a>    <span class="k">def</span> <span class="nf">beatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The beatmap this replay was played on.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        library: :class:`slider.library.Library`</span>
<span class="sd">            The library used by the calling</span>
<span class="sd">            :class:`circleguard.circleguard.Circleguard` instance. Replays which</span>
<span class="sd">            have already been downloaded and are cached in this library may be</span>
<span class="sd">            returned here instead of redownloading them.</span>
<span class="sd">            &lt;br&gt;</span>
<span class="sd">            Beatmaps which we download or create in this method, but were not</span>
<span class="sd">            previously stored in the library, may also be stored into the</span>
<span class="sd">            library for future use as a result of calling this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`slider.beatmap.Beatmap`</span>
<span class="sd">            The beatmap this replay was played on.</span>
<span class="sd">        None</span>
<span class="sd">            If we do not know what beatmap this replay was played on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">available</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># prefer loading from disk, it&#39;s cheaper than potentially downloading</span>
        <span class="c1"># the beatmap from osu! servers</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
            <span class="c1"># by default we don&#39;t save beatmaps that are already saved on disk.</span>
            <span class="c1"># Subclasses should override `#beatmap` and pass `copy=True` here</span>
            <span class="c1"># in their overridden method if they want to copy the beatmap to the</span>
            <span class="c1"># library&#39;s directory.</span>
            <span class="k">return</span> <span class="n">library</span><span class="o">.</span><span class="n">beatmap_from_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">library</span><span class="o">.</span><span class="n">lookup_by_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_process_replay_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocesses the replay data (turns it into numpy arrays) for fast</span>
<span class="sd">        manipulation when investigating.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        replay_data: list[:class:`~circleparse.Replay.ReplayEvent`]</span>
<span class="sd">            A list of :class:`~circleparse.Replay.ReplayEvent` objects,</span>
<span class="sd">            representing the actual data of the replay. If the replay could not</span>
<span class="sd">            be loaded, this should be ``None``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method must be called before a replay can be considered loaded</span>
<span class="sd">        (ie before you set ``loaded`` to ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span>
        <span class="c1"># replay wasn&#39;t available, can&#39;t preprocess the data</span>
        <span class="k">if</span> <span class="n">replay_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># remove invalid zero time frame at beginning of replay</span>
        <span class="c1"># https://github.com/ppy/osu/blob/1587d4b26fbad691242544a62dbf017a78705ae3/osu.Game/Scoring/Legacy/LegacyScoreDecoder.cs#L242-L245</span>
        <span class="k">if</span> <span class="n">replay_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time_since_previous_action</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># t, x, y, k</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="c1">## TODO try to use a peekable iterator to use an iter for above as well</span>
        <span class="c1"># use an iter an an optimization so we don&#39;t recreate the list when</span>
        <span class="c1"># taking (and removing) the first element</span>
        <span class="n">replay_data</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="c1"># The following comments in this method are guesswork, but seems to</span>
        <span class="c1"># accurately describe replays. This references the &quot;first&quot; frame</span>
        <span class="c1"># assuming that we have already removed the truly first zero time</span>
        <span class="c1"># frame, if it is present. So technically the &quot;first&quot; frame below may</span>
        <span class="c1"># be the second frame.</span>
        <span class="c1"># There are two possibilities for replays:</span>
        <span class="c1"># * for replays with a skip in the beginning, the first frame time is</span>
        <span class="c1">#   the skip duration. The next frame after that will have a negative</span>
        <span class="c1">#   time, to account for the replay data before the skip.</span>
        <span class="c1"># * for replays without a skip in the beginning, the first frame time</span>
        <span class="c1">#   is -1.</span>
        <span class="c1"># Since in the first case the first frame time is a large positive,</span>
        <span class="c1"># this would make ``highest_running_t`` large and cause all replay data</span>
        <span class="c1"># before the skip to be ignored. To solve this, we initialize</span>
        <span class="c1"># ``running_t`` to the first frame&#39;s time.</span>
        <span class="n">running_t</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span><span class="o">.</span><span class="n">time_since_previous_action</span>
        <span class="c1"># We consider negative time frames in the middle of replays to be</span>
        <span class="c1"># valid, with a caveat. Their negative time is counted toward</span>
        <span class="c1"># ``running_t`` (that is, decreases ``running_t``), but any frames</span>
        <span class="c1"># after it are ignored, until the total time passed of ignored frames</span>
        <span class="c1"># is greater than or equal to the negative frame.</span>
        <span class="c1"># There&#39;s one more catch - the frame that brings us *out* of this</span>
        <span class="c1"># &quot;negative time&quot; section where we&#39;re ignoring frames will cause a</span>
        <span class="c1"># special frame to be inserted, which has the same time as the frame</span>
        <span class="c1"># that brought us *into* the negative time section, and specially</span>
        <span class="c1"># calculated x and y positions. Details below.</span>
        <span class="c1"># I do not know why stable treats negative time frames in this way.</span>
        <span class="c1"># It is not what lazer does, as far as I can tell. But it is the only</span>
        <span class="c1"># reasonable explanation for stable behavior. This solution may not,</span>
        <span class="c1"># however, be the canonical solution.</span>
        <span class="n">highest_running_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span>
        <span class="c1"># The last positive frame we encountered before entering a negative</span>
        <span class="c1"># section.</span>
        <span class="n">last_positive_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># the running time when we encountered ``last_positive_frame``. We need</span>
        <span class="c1"># to save this as we do not store this information in each individual</span>
        <span class="c1"># frame.</span>
        <span class="n">last_positive_frame_cum_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">previous_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">replay_data</span><span class="p">:</span>
            <span class="c1"># check if we were in a negative section of the play at the</span>
            <span class="c1"># previous frame (f0) before applying the current frame (f1), so we</span>
            <span class="c1"># can apply special logic if f1 is the frame that gets us out of</span>
            <span class="c1"># the negative section.</span>
            <span class="n">was_in_negative_section</span> <span class="o">=</span> <span class="n">running_t</span> <span class="o">&lt;</span> <span class="n">highest_running_t</span>

            <span class="n">e_t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">time_since_previous_action</span>
            <span class="n">running_t</span> <span class="o">+=</span> <span class="n">e_t</span>
            <span class="n">highest_running_t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">highest_running_t</span><span class="p">,</span> <span class="n">running_t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">running_t</span> <span class="o">&lt;</span> <span class="n">highest_running_t</span><span class="p">:</span>
                <span class="c1"># if we weren&#39;t in a negative section in f0, f1 is the first</span>
                <span class="c1"># frame to bring us into one, so f0 is the last positive frame.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">was_in_negative_section</span><span class="p">:</span>
                    <span class="n">last_positive_frame</span> <span class="o">=</span> <span class="n">previous_frame</span>
                    <span class="c1"># we want to set it to the cumulative time before f1</span>
                    <span class="c1"># was processed, so subtract out the current e_t</span>
                    <span class="n">last_positive_frame_cum_time</span> <span class="o">=</span> <span class="n">running_t</span> <span class="o">-</span> <span class="n">e_t</span>
                <span class="n">previous_frame</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">continue</span>

            <span class="c1"># if we get here, f1 brought us out of the negative section. In</span>
            <span class="c1"># this case, osu! actually inserts a new frame, with:</span>
            <span class="c1"># * t = the cumulative time at the last positive frame (yes, this</span>
            <span class="c1">#   means there are two frames at the same time in the replay</span>
            <span class="c1">#   playback).</span>
            <span class="c1"># * x, y = a weighted average between the positions of f0 and f1,</span>
            <span class="c1">#   weighted by how close the last positive frame&#39;s time is to each</span>
            <span class="c1">#   of the two frames&#39; times.</span>
            <span class="c1"># * k = the keypresses of the last positive frame.</span>
            <span class="k">if</span> <span class="n">was_in_negative_section</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">)</span>

                <span class="c1"># this is [running_t at f0, running_t at f1], to interpolate</span>
                <span class="c1"># the last positive frame&#39;s time between.</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="n">running_t</span> <span class="o">-</span> <span class="n">e_t</span><span class="p">,</span> <span class="n">running_t</span><span class="p">]</span>

                <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_frame</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_frame</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

                <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_positive_frame</span><span class="o">.</span><span class="n">keys_pressed</span><span class="p">)</span>

            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_t</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">keys_pressed</span><span class="p">)</span>
            <span class="n">previous_frame</span> <span class="o">=</span> <span class="n">e</span>

        <span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># sort our data by t. Stable so we don&#39;t reorder frames with equal</span>
        <span class="c1"># times</span>
        <span class="n">t_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_id</span>

    <span class="nd">@map_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keydowns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of the keys pressed for each frame that were not pressed in the</span>
<span class="sd">        previous frame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        If the first frame (``f1``) has keys ``K1`` and ``f2`` has keys</span>
<span class="sd">        ``K1 + K2``, then ``keydowns[1]`` is ``K2``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># can&#39;t do `if not self._keydowns` because the truth value of an</span>
        <span class="c1"># ndarray is ambiguous</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keypresses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&amp;</span> <span class="n">KEY_MASK</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span> <span class="o">=</span> <span class="n">keypresses</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">keypresses</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;Replay(timestamp=</span><span class="si">{self.timestamp}</span><span class="s2">,map_id=</span><span class="si">{self.map_id}</span><span class="s2">,&quot;</span>
            <span class="n">f</span><span class="s2">&quot;user_id=</span><span class="si">{self.user_id}</span><span class="s2">,mods=</span><span class="si">{self.mods}</span><span class="s2">,&quot;</span>
            <span class="n">f</span><span class="s2">&quot;replay_id=</span><span class="si">{self.replay_id}</span><span class="s2">,weight=</span><span class="si">{self.weight}</span><span class="s2">,&quot;</span>
            <span class="n">f</span><span class="s2">&quot;loaded=</span><span class="si">{self.loaded}</span><span class="s2">,username=</span><span class="si">{self.username}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;Replay by </span><span class="si">{self.username}</span><span class="s2"> on </span><span class="si">{self.map_id}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="ReplayMap"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayMap">[docs]</a><span class="k">class</span> <span class="nc">ReplayMap</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` that was submitted to online servers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The id of the map the replay was played on.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The id of the player who played the replay.</span>
<span class="sd">    mods: ModCombination</span>
<span class="sd">        The mods the replay was played with. If ``None``, the</span>
<span class="sd">        highest scoring replay of ``user_id`` on ``map_id`` will be loaded,</span>
<span class="sd">        regardless of mod combination. Otherwise, the replay with ``mods``</span>
<span class="sd">        will be loaded.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is unloaded:</span>
<span class="sd">      * map_id</span>
<span class="sd">      * user_id</span>
<span class="sd">      * mods (if passed)</span>
<span class="sd">    &lt;br&gt;</span>
<span class="sd">    In addition to the above, the following replay-related attributes are</span>
<span class="sd">    available (not ``None``) when this replay is loaded:</span>
<span class="sd">      * timestamp</span>
<span class="sd">      * username</span>
<span class="sd">      * mods</span>
<span class="sd">      * replay_id</span>
<span class="sd">      * replay_data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">HEAVY</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ReplayMap&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">map_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">username</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span>

<div class="viewcode-block" id="ReplayMap.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayMap.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the data for this replay from the api.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``replay.loaded`` is ``True``, this method has no effect.</span>
<span class="sd">        ``replay.loaded`` is set to ``True`` after this method is finished.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># only listen to the parent&#39;s cache if ours is not set. Lower takes</span>
        <span class="c1"># precedence</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> already loaded, not loading&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">user_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
                <span class="n">mods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="c1"># estimate version with timestamp, this is only accurate if the user</span>
        <span class="c1"># keeps their game up to date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="n">concrete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">username</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_id</span>

        <span class="n">replay_data</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_data</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;Finished loading </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the two maps are equal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This does not take into account the</span>
<span class="sd">        ``cache`` attribute, because equality here means &quot;do they represent the</span>
<span class="sd">        same replays&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayMap</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">()</span> <span class="ow">and</span> <span class="n">loadable</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">map_id</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;ReplayMap(timestamp=</span><span class="si">{self.timestamp}</span><span class="s2">,map_id=</span><span class="si">{self.map_id}</span><span class="s2">&quot;</span>
            <span class="n">f</span><span class="s2">&quot;,user_id=</span><span class="si">{self.user_id}</span><span class="s2">,mods=</span><span class="si">{self.mods}</span><span class="s2">,cache=</span><span class="si">{self.cache}</span><span class="s2">,&quot;</span>
            <span class="n">f</span><span class="s2">&quot;replay_id=</span><span class="si">{self.replay_id}</span><span class="s2">,loaded=</span><span class="si">{self.loaded}</span><span class="s2">,&quot;</span>
            <span class="n">f</span><span class="s2">&quot;username=</span><span class="si">{self.username}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;ReplayMap(map_id=</span><span class="si">{self.map_id}</span><span class="s2">,user_id=</span><span class="si">{self.user_id}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;mods=</span><span class="si">{self.mods}</span><span class="s2">,cache=</span><span class="si">{self.cache}</span><span class="s2">,loaded=</span><span class="si">{self.loaded}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;{&#39;Loaded&#39; if self.loaded else &#39;Unloaded&#39;} ReplayMap by &quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.user_id}</span><span class="s2"> on </span><span class="si">{self.map_id}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayPath"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayPath">[docs]</a><span class="k">class</span> <span class="nc">ReplayPath</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` saved locally in a ``.osr`` file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str or :class:`os.PathLike`</span>
<span class="sd">        The path to the replay file.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that currently</span>
<span class="sd">        we do not cache :class:`~.ReplayPath` regardless of this parameter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ReplayPaths have no replay-related attributes available (not ``None``) when</span>
<span class="sd">    they are unloaded.</span>
<span class="sd">    &lt;br&gt;</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is loaded:</span>
<span class="sd">      * timestamp</span>
<span class="sd">      * map_id</span>
<span class="sd">      * username</span>
<span class="sd">      * user_id</span>
<span class="sd">      * mods</span>
<span class="sd">      * replay_id</span>
<span class="sd">      * beatmap_hash</span>
<span class="sd">      * replay_data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">LIGHT</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ReplayPath&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ReplayPath.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayPath.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the data for this replay from the osr file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``). Note that currently</span>
<span class="sd">            we do not cache :class:`~.ReplayPath` regardless of this parameter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``replay.loaded`` is ``True``, this method has no effect.</span>
<span class="sd">        ``replay.loaded`` is set to ``True`` after this method is finished.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading ReplayPath </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> already loaded, not loading&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">loaded</span> <span class="o">=</span> <span class="n">circleparse</span><span class="o">.</span><span class="n">parse_replay_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">game_version</span><span class="p">,</span> <span class="n">concrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">map_id</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">player_name</span>
        <span class="c1"># our `user_id` attribute is lazy loaded, so we need to retain the</span>
        <span class="c1"># `Loader#user_id` function to use later to load it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">mod_combination</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">replay_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">play_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;Finished loading </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># we don&#39;t have a user_id_func if we&#39;re not loaded, so early return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span>

    <span class="nd">@user_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="n">user_id</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether these replay paths are equal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If one or both replay paths don&#39;t have replay data, this checks path</span>
<span class="sd">        equality. If both replay paths have replay data, this checks the</span>
<span class="sd">        equality of their replay data.</span>
<span class="sd">        &lt;br&gt;</span>
<span class="sd">        The reason we don&#39;t check path after both are loaded is to avoid</span>
<span class="sd">        true in situations like this:</span>

<span class="sd">        ```</span>
<span class="sd">        r1 = ReplayPath(&quot;./1.osr&quot;)</span>
<span class="sd">        cg.load(r1)</span>
<span class="sd">        # change the file located at ./1.osr to another osr file</span>
<span class="sd">        r2 = ReplayPath(&quot;./1.osr&quot;)</span>
<span class="sd">        cg.load(r2)</span>
<span class="sd">        r1 == r2 # should be False, as they have differing replay data</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayPath</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">()</span> <span class="ow">and</span> <span class="n">loadable</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;ReplayPath(path=</span><span class="si">{self.path}</span><span class="s2">,map_id=</span><span class="si">{self.map_id}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;user_id=</span><span class="si">{self.user_id}</span><span class="s2">,mods=</span><span class="si">{self.mods}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;replay_id=</span><span class="si">{self.replay_id}</span><span class="s2">,weight=</span><span class="si">{self.weight}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;loaded=</span><span class="si">{self.loaded}</span><span class="s2">,username=</span><span class="si">{self.username}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;ReplayPath(path=</span><span class="si">{self.path}</span><span class="s2">,weight=</span><span class="si">{self.weight}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;loaded=</span><span class="si">{self.loaded}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;Loaded ReplayPath by </span><span class="si">{self.username}</span><span class="s2"> on </span><span class="si">{self.map_id}</span><span class="s2"> at&quot;</span>
                <span class="n">f</span><span class="s2">&quot; </span><span class="si">{self.path}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;Unloaded ReplayPath at </span><span class="si">{self.path}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="ReplayString"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayString">[docs]</a><span class="k">class</span> <span class="nc">ReplayString</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` saved locally in a ``.osr`` file, when the file has</span>
<span class="sd">    already been read as a string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    replay_data_str: str</span>
<span class="sd">        The contents of the replay file as a string.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that currently</span>
<span class="sd">        we do not cache :class:`~.ReplayString` regardless of this parameter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ReplayPaths have no replay-related attributes available (not ``None``) when</span>
<span class="sd">    they are unloaded.</span>
<span class="sd">    &lt;br&gt;</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is loaded:</span>
<span class="sd">      * timestamp</span>
<span class="sd">      * map_id</span>
<span class="sd">      * username</span>
<span class="sd">      * user_id</span>
<span class="sd">      * mods</span>
<span class="sd">      * replay_id</span>
<span class="sd">      * beatmap_hash</span>
<span class="sd">      * replay_data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; replay_data = open(&quot;replay.osr&quot;, &quot;rb&quot;).read()</span>
<span class="sd">    &gt;&gt;&gt; r = ReplayString(replay_data)</span>
<span class="sd">    &gt;&gt;&gt; cg.load(r)</span>
<span class="sd">    &gt;&gt;&gt; print(cg.ur(r))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_data_str</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">LIGHT</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ReplayString&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span> <span class="o">=</span> <span class="n">replay_data_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ReplayString.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayString.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the data for this replay from the string replay data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``). Note that currently</span>
<span class="sd">            we do not cache :class:`~.ReplayString` regardless of this</span>
<span class="sd">            parameter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``replay.loaded`` is ``True``, this method has no effect.</span>
<span class="sd">        ``replay.loaded`` is set to ``True`` after this method is finished.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading ReplayString </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> already loaded, not loading&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">loaded</span> <span class="o">=</span> <span class="n">circleparse</span><span class="o">.</span><span class="n">parse_replay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">,</span> <span class="n">pure_lzma</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">game_version</span><span class="p">,</span> <span class="n">concrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">map_id</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">player_name</span>
        <span class="c1"># our `user_id` attribute is lazy loaded, so we need to retain the</span>
        <span class="c1"># `Loader#user_id` function to use later to load it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">mod_combination</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">replay_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">play_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;Finished loading </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># we don&#39;t have a user_id_func if we&#39;re not loaded, so early return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span>

    <span class="nd">@user_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="n">user_id</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayString</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data_str</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;ReplayString(len(replay_data_str)=&quot;</span>
                <span class="n">f</span><span class="s2">&quot;{len(self.replay_data_str)},map_id=</span><span class="si">{self.map_id}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;user_id=</span><span class="si">{self.user_id}</span><span class="s2">,mods=</span><span class="si">{self.mods}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;replay_id=</span><span class="si">{self.replay_id}</span><span class="s2">,weight=</span><span class="si">{self.weight}</span><span class="s2">,&quot;</span>
                <span class="n">f</span><span class="s2">&quot;loaded=</span><span class="si">{self.loaded}</span><span class="s2">,username=</span><span class="si">{self.username}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;ReplayString(len(replay_data_str)={len(self.replay_data_str)})&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;Loaded ReplayString by </span><span class="si">{self.username}</span><span class="s2"> on </span><span class="si">{self.map_id}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;Unloaded ReplayString with {len(self.replay_data_str)} &quot;</span>
            <span class="s2">&quot;chars of data&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayID"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayID">[docs]</a><span class="k">class</span> <span class="nc">ReplayID</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` that was submitted online and is represented by a unique</span>
<span class="sd">    replay id.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    replay_id: int</span>
<span class="sd">        The id of the replay.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that we currently</span>
<span class="sd">        do not cache ReplayIDs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is unloaded:</span>
<span class="sd">      * replay_id</span>
<span class="sd">    &lt;br&gt;</span>
<span class="sd">    In addition to the above, the following replay-related attributes are</span>
<span class="sd">    available (not ``None``) when this replay is loaded:</span>
<span class="sd">      * replay_data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_id</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">HEAVY</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">replay_id</span>

<div class="viewcode-block" id="ReplayID.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayID.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="c1"># TODO file github issue about loading info from replay id, right now we</span>
        <span class="c1"># can literally only load the replay data which isn&#39;t that useful</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">replay_data</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_data_from_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">replay_id</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="CachedReplay"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.CachedReplay">[docs]</a><span class="k">class</span> <span class="nc">CachedReplay</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is intended to be instantiated from</span>
<span class="sd">    :func:`~.ReplayCache.load_info` and should not be instantiated manually.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">mods</span><span class="p">,</span> <span class="n">replay_data</span><span class="p">,</span> <span class="n">replay_id</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">mods</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">replay_id</span>

<div class="viewcode-block" id="CachedReplay.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.CachedReplay.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">decompressed</span> <span class="o">=</span> <span class="n">wtc</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="n">circleparse</span><span class="o">.</span><span class="n">parse_replay</span><span class="p">(</span><span class="n">decompressed</span><span class="p">,</span> <span class="n">pure_lzma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">play_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">replay_id</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>